import fs from 'fs'
import { executeWithProgressBar, createEntityChunks } from './common/Helper';
import { getEntities, getAuditInfo, getAllHistory } from './common/Requests';
import { DeploymentEvent, EntityType, FileHash, EntityId, Entity, EntityBase, EntityContent } from "./common/types";

async function run() {
    // This file is generated by executing an 'ls' on the server
    const content = fs.readFileSync('/Users/nchamo/Desktop/storage.txt').toString()
    const entries: [FileHash, number][] = content.split('\n')
        .map(line => line.trim())
        .map(line => {
            const pieces = line.split(' ')
            const size = parseInt(pieces[0]) / 1024
            const hash = pieces[pieces.length - 1]
            return [hash, size]
        })

    const fileSizes = new Map(entries)

    await runCheck('https://peer.decentraland.org/content', fileSizes)

}

async function runCheck(serverAddress, fileSizes: Map<FileHash, number>): Promise<void> {

    const history = await getAllHistory(serverAddress, Date.now())

    const profiles = history.filter(({ entityType }) => entityType === 'profile').length
    const scenes = history.length - profiles

    console.log(`There are ${profiles} profiles and ${scenes} scenes`)

    const notOverwritten = await checkAuditInfo(serverAddress, history);

    const referencedEntities: Map<FileHash, EntityType> = await checkEntities(serverAddress, notOverwritten);

    let totalScene = 0
    let totalProfile = 0
    for (const [hash, type] of referencedEntities.entries()) {
        if (type === 'scene') {
            totalScene += fileSizes.get(hash) ?? 0
        } else {
            totalProfile += fileSizes.get(hash) ?? 0
        }
    }

    console.log('TOTAL SCENE SIZE IN KB IS: ', totalScene)
    console.log('TOTAL PROFILE SIZE IN KB IS: ', totalProfile)

}

async function checkEntities(serverAddress: string, entities: EntityBase[]): Promise<Map<FileHash, EntityType>> {
    const referencedContent: Map<FileHash, EntityType> = new Map()

    const entitiesChunks: EntityBase[][] = createEntityChunks(entities);

    // Check entities
    await executeWithProgressBar('Checking entities', entitiesChunks, async (entities: { entityType: EntityType; entityId: EntityId; }[]) => {
        const entityType: EntityType = entities[0].entityType;
        const ids = entities.map(({ entityId }) => entityId);
        const fetchedEntities: Entity[] = await getEntities(serverAddress, entityType, ids);
        for (const entity of fetchedEntities) {
            referencedContent.set(entity.id, entity.type)
            const contentFiles: EntityContent[] = entity.content ?? []
            for (const content of contentFiles) {
                referencedContent.set(content.hash, entity.type)
            }
        }
    });

    return referencedContent
}

async function checkAuditInfo(serverAddress: string, history: DeploymentEvent[]): Promise<EntityBase[]> {
    const notOverwritten: EntityBase[] = []

    await executeWithProgressBar('Checking audit info', history, async ({ entityType, entityId }) => {
        const auditInfo = await getAuditInfo(serverAddress, entityType, entityId)
        if (!auditInfo.overwrittenBy) {
            notOverwritten.push({ entityId, entityType })
        }
    });

    return notOverwritten
}


run().then(() => console.log("Done!"))

